#compdef devcontainer

# Helper: Get cached help output (cache in /tmp to avoid repeated calls)
_devcontainer_get_help() {
  local cmd_name="$1"
  local cache_file="/tmp/devcontainer_help_${cmd_name//\//_}.cache"

  # Return cache if fresh (< 1 hour old)
  if [[ -f "$cache_file" ]] && [[ $(( $(date +%s) - $(stat -f%m "$cache_file") )) -lt 3600 ]]; then
    cat "$cache_file"
    return 0
  fi

  # Fetch and cache
  if [[ -z "$cmd_name" ]]; then
    devcontainer --help 2>/dev/null | tee "$cache_file"
  else
    devcontainer "$cmd_name" --help 2>/dev/null | tee "$cache_file"
  fi
}

# Parse subcommands from help output (POSIX awk compatible)
_devcontainer_list_subcommands() {
  _devcontainer_get_help '' | awk '
    /^Commands:/ { in_commands=1; next }
    in_commands && /^[[:space:]]*devcontainer[[:space:]]+/ {
      # Remove ANSI colors
      gsub(/\x1b\[[0-9;]*m/, "")
      line = $0
      sub(/^[ \t]+/, "", line)

      # Drop leading executable name and capture command token.
      sub(/^devcontainer[ \t]+/, "", line)
      cmd = line
      sub(/[ \t].*$/, "", cmd)

      # Description starts after the usage column (2+ spaces separator).
      desc = ""
      if (match(line, /[ \t][ \t]+/)) {
        desc = substr(line, RSTART + RLENGTH)
        gsub(/^[ \t]+|[ \t]+$/, "", desc)
      }

      if (cmd != "" && desc != "") {
        printf "%s[%s]\n", cmd, desc
      }
    }
    in_commands && /^[[:space:]]*$/ { in_commands=0 }
  '
}

# Parse options from subcommand help output (POSIX awk compatible)
_devcontainer_list_options() {
  local subcommand="$1"
  _devcontainer_get_help "$subcommand" | awk '
    /^Options:/ || /^Flags:/ { in_options=1; next }
    in_options && /^[[:space:]]*-/ {
      # Remove ANSI colors
      gsub(/\x1b\[[0-9;]*m/, "")
      line = $0
      sub(/^[ \t]+/, "", line)

      # Split option specification from description by 2+ spaces.
      spec = line
      desc = ""
      if (match(line, /[ \t][ \t]+/)) {
        spec = substr(line, 1, RSTART - 1)
        desc = substr(line, RSTART + RLENGTH)
      }
      gsub(/^[ \t]+|[ \t]+$/, "", spec)
      gsub(/^[ \t]+|[ \t]+$/, "", desc)

      has_value = 0
      if (desc ~ /\[(string|number|array)\]/ || desc ~ /\[choices:[^]]+\]/) {
        has_value = 1
      }
      if (desc ~ /\[boolean\]/) {
        has_value = 0
      }

      # Remove yargs type metadata from the visible help text.
      gsub(/\[[^]]+\]/, "", desc)
      gsub(/^[ \t]+|[ \t]+$/, "", desc)
      gsub(/[ \t]+/, " ", desc)

      # Emit one completion spec per option token, supporting forms like:
      #   --help
      #   -h, --help
      #   --help, -h
      n = split(spec, parts, /,[ \t]*/)
      for (i = 1; i <= n; i++) {
        flag = parts[i]
        gsub(/^[ \t]+|[ \t]+$/, "", flag)
        # Strip value placeholders from the option token.
        sub(/[ \t]+<[^>]+>.*/, "", flag)
        sub(/[ \t]+[A-Z_][A-Z0-9_-]*.*/, "", flag)
        sub(/=.*/, "", flag)

        if (flag != "" && flag ~ /^--?[[:alnum:]][[:alnum:]-]*$/) {
          if (has_value) {
            printf "%s=[%s]\n", flag, desc
          } else {
            printf "%s[%s]\n", flag, desc
          }
        }
      }
    }
    in_options && /^[[:space:]]*$/ { in_options=0 }
  '
}

# Main completion function
_devcontainer() {
  # First argument after `devcontainer` is always the subcommand.
  if (( CURRENT == 2 )); then
    local -a subcmds
    subcmds=( ${(f)"$(_devcontainer_list_subcommands)"} )
    if (( ${#subcmds[@]} > 0 )); then
      compstate[list]=list
      _values 'devcontainer subcommand' "${subcmds[@]}"
    else
      echo "Warning: Failed to parse subcommands from help output. Using fallback list." >&2
      compstate[list]=list
      _values 'devcontainer subcommand' \
        'attach[Attach to a running container]' \
        'build[Build a devcontainer]' \
        'exec[Run a command in the container]' \
        'list[List devcontainers or images]' \
        'open[Open folder in devcontainer]' \
        'rebuild[Rebuild the devcontainer]' \
        'shell[Open an interactive shell in container]' \
        'start[Start the devcontainer]' \
        'stop[Stop the devcontainer]' \
        'help[Show help for a command]'
    fi
    return
  fi

  # Remaining args belong to the selected subcommand.
  local subcommand="$words[2]"
  local -a opts opt_names
  opts=( ${(f)"$(_devcontainer_list_options "$subcommand")"} )

  if (( ${#opts[@]} == 0 )); then
    _files
    return
  fi

  # Complete flag names for both "-" and "--" prefixes.
  if [[ "$words[$CURRENT]" == -* ]]; then
    opt_names=( "${(@)opts%%\[*}" )
    opt_names=( "${(@)opt_names%=}" )
    compstate[list]=list
    compadd -Q -- "${opt_names[@]}"
    return
  fi

  # Otherwise, let _arguments handle option metadata and fallback file completion.
  _arguments -C \
    "${opts[@]}" \
    '*: :_files'
}

# For autoloaded completion files that define a function body, invoke it on first load.
_devcontainer "$@"
