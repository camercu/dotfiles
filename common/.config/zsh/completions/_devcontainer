#compdef devcontainer

typeset -gr _DEVCONTAINER_CACHE_TTL=3600
typeset -gr _DEVCONTAINER_CACHE_ROOT="${XDG_CACHE_HOME:-$HOME/.cache}/zsh/devcontainer"
typeset -ga _DEVCONTAINER_FALLBACK_SUBCOMMANDS=(
  'attach[Attach to a running container]'
  'build[Build a devcontainer]'
  'exec[Run a command in the container]'
  'list[List devcontainers or images]'
  'open[Open folder in devcontainer]'
  'rebuild[Rebuild the devcontainer]'
  'shell[Open an interactive shell in container]'
  'start[Start the devcontainer]'
  'stop[Stop the devcontainer]'
  'help[Show help for a command]'
)

_devcontainer_cache_file_for() {
  local subcommand="$1"
  local cache_key="${subcommand//\//_}"

  printf "%s/help_%s.cache\n" "$_DEVCONTAINER_CACHE_ROOT" "$cache_key"
}

_devcontainer_cache_is_fresh() {
  local cache_file="$1"
  local -a zstat_out
  local -i now mtime

  [[ -f "$cache_file" ]] || return 1

  now=${EPOCHSECONDS}
  zmodload -F zsh/stat b:zstat 2>/dev/null || zmodload zsh/stat 2>/dev/null
  if (( ${+builtins[zstat]} )) && zstat -A zstat_out +mtime -- "$cache_file" 2>/dev/null; then
    mtime=${zstat_out[1]}
  else
    mtime=0
  fi

  (( now - mtime < _DEVCONTAINER_CACHE_TTL ))
}

_devcontainer_fetch_help() {
  local subcommand="$1"

  if [[ -z "$subcommand" ]]; then
    devcontainer --help 2>/dev/null
  else
    devcontainer "$subcommand" --help 2>/dev/null
  fi
}

_devcontainer_read_help() {
  local subcommand="$1"
  local cache_file cache_tmp

  command -v devcontainer &>/dev/null || return 1

  [[ -d "$_DEVCONTAINER_CACHE_ROOT" ]] || mkdir -p -- "$_DEVCONTAINER_CACHE_ROOT" 2>/dev/null || return 1

  cache_file="$(_devcontainer_cache_file_for "$subcommand")"
  cache_tmp="${cache_file}.tmp.$$"

  if _devcontainer_cache_is_fresh "$cache_file"; then
    cat "$cache_file"
    return 0
  fi

  _devcontainer_fetch_help "$subcommand" >|"$cache_tmp" || return 1
  mv -f -- "$cache_tmp" "$cache_file" 2>/dev/null || return 1
  cat "$cache_file"
}

_devcontainer_parse_subcommands_from_help() {
  awk '
    /^Commands:/ { in_commands=1; next }
    in_commands && /^[[:space:]]*devcontainer[[:space:]]+/ {
      # Remove ANSI colors
      gsub(/\x1b\[[0-9;]*m/, "")
      line = $0
      sub(/^[ \t]+/, "", line)

      # Drop leading executable name and capture command token.
      sub(/^devcontainer[ \t]+/, "", line)
      cmd = line
      sub(/[ \t].*$/, "", cmd)

      # Description starts after the usage column (2+ spaces separator).
      desc = ""
      if (match(line, /[ \t][ \t]+/)) {
        desc = substr(line, RSTART + RLENGTH)
        gsub(/^[ \t]+|[ \t]+$/, "", desc)
      }

      if (cmd != "" && desc != "") {
        printf "%s[%s]\n", cmd, desc
      }
    }
    in_commands && /^[[:space:]]*$/ { in_commands=0 }
  '
}

_devcontainer_parse_options_from_help() {
  awk '
    /^Options:/ || /^Flags:/ { in_options=1; next }
    in_options && /^[[:space:]]*-/ {
      # Remove ANSI colors
      gsub(/\x1b\[[0-9;]*m/, "")
      line = $0
      sub(/^[ \t]+/, "", line)

      # Split option specification from description by 2+ spaces.
      spec = line
      desc = ""
      if (match(line, /[ \t][ \t]+/)) {
        spec = substr(line, 1, RSTART - 1)
        desc = substr(line, RSTART + RLENGTH)
      }
      gsub(/^[ \t]+|[ \t]+$/, "", spec)
      gsub(/^[ \t]+|[ \t]+$/, "", desc)

      has_value = 0
      if (desc ~ /\[(string|number|array)\]/ || desc ~ /\[choices:[^]]+\]/) {
        has_value = 1
      }
      if (desc ~ /\[boolean\]/) {
        has_value = 0
      }

      # Remove yargs type metadata from the visible help text.
      gsub(/\[[^]]+\]/, "", desc)
      gsub(/^[ \t]+|[ \t]+$/, "", desc)
      gsub(/[ \t]+/, " ", desc)

      # Emit one completion spec per option token, supporting forms like:
      #   --help
      #   -h, --help
      #   --help, -h
      n = split(spec, parts, /,[ \t]*/)
      for (i = 1; i <= n; i++) {
        flag = parts[i]
        gsub(/^[ \t]+|[ \t]+$/, "", flag)
        # Strip value placeholders from the option token.
        sub(/[ \t]+<[^>]+>.*/, "", flag)
        sub(/[ \t]+[A-Z_][A-Z0-9_-]*.*/, "", flag)
        sub(/=.*/, "", flag)

        if (flag != "" && flag ~ /^--?[[:alnum:]][[:alnum:]-]*$/) {
          if (has_value) {
            printf "%s=[%s]\n", flag, desc
          } else {
            printf "%s[%s]\n", flag, desc
          }
        }
      }
    }
    in_options && /^[[:space:]]*$/ { in_options=0 }
  '
}

_devcontainer_list_subcommands() {
  _devcontainer_read_help '' | _devcontainer_parse_subcommands_from_help
}

_devcontainer_list_options() {
  local subcommand="$1"
  _devcontainer_read_help "$subcommand" | _devcontainer_parse_options_from_help
}

_devcontainer_warn_parse_fallback() {
  echo "Warning: Failed to parse subcommands from help output. Using fallback list." >&2
}

_devcontainer_complete_subcommand() {
  local -a subcommands
  subcommands=( ${(f)"$(_devcontainer_list_subcommands)"} )

  if (( ${#subcommands[@]} == 0 )); then
    _devcontainer_warn_parse_fallback
    subcommands=( "${_DEVCONTAINER_FALLBACK_SUBCOMMANDS[@]}" )
  fi

  compstate[list]=list
  _values 'devcontainer subcommand' "${subcommands[@]}"
}

_devcontainer_complete_option_names() {
  local -a opts opt_names
  opts=( "$@" )
  opt_names=( "${(@)opts%%\[*}" )
  opt_names=( "${(@)opt_names%=}" )

  compstate[list]=list
  compadd -Q -- "${opt_names[@]}"
}

_devcontainer_complete_args() {
  local subcommand="$words[2]"
  local -a opts
  opts=( ${(f)"$(_devcontainer_list_options "$subcommand")"} )

  if (( ${#opts[@]} == 0 )); then
    _files
    return
  fi

  # Complete flag names for both "-" and "--" prefixes.
  if [[ "$words[$CURRENT]" == -* ]]; then
    _devcontainer_complete_option_names "${opts[@]}"
    return
  fi

  # Otherwise, let _arguments handle option metadata and fallback file completion.
  _arguments -C \
    "${opts[@]}" \
    '*: :_files'
}

# Main entry point for completion.
_devcontainer() {
  if (( CURRENT == 2 )); then
    _devcontainer_complete_subcommand
    return
  fi

  _devcontainer_complete_args
}

if [[ "$funcstack[1]" == "_devcontainer" ]]; then
  _devcontainer "$@"
elif (( $+functions[compdef] )); then
  # Register the completion function for the 'devcontainer' command.
  compdef _devcontainer devcontainer
fi
